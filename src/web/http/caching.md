# HTTP 缓存

## 一、介绍

缓存机制是指客户端（浏览器）或中间代理服务器（例如 CDN）在本地存储从服务器获取的资源，以便在后续请求中可以直接使用缓存的资源，而不需要再次向服务器请求这些资源。

## 二、缓存策略

HTTP 缓存的策略，分为强缓存和协商缓存两种。

### 2.1 强缓存

#### （1）什么是强缓存？

强缓存通过 HTTP 头部控制资源的缓存行为，主要使用 `Cache-Control` 和 `Expires` 响应头。浏览器在接收到这些头部信息后，将资源和相应的缓存控制信息存储在本地缓存中。在后续请求中，如果缓存仍然有效，浏览器将直接从本地缓存中读取资源，而不再向服务器发送请求。

#### （2）Expires

`Expires` 是 HTTP 1.0 引入的缓存控制头，用于指定资源的过期时间。它是一个绝对时间点，在此时间点之后，缓存资源被视为过期，需要重新从服务器获取。

```http
Expires: Wed, 21 Oct 2023 07:28:00 GMT
```

上面的代码，表示资源在 2023 年 10 月 21 日 07:28:00 之后过期。

注意，由于浏览器在根据 `Expires` 头字段判断资源是否过期时，使用的是本地时间，而本地时间有可能被恶意篡改，所以在使用 `Expires` 作为强缓存依据时要特别注意。

#### （3）Cache-Control

`Cache-Control` 是 HTTP 1.1 引入的缓存控制头，相比 `Expires` 提供了更强大和灵活的控制选项。以下是 `Cache-Control` 头的一些常用指令：

- `public`：指示资源可以被任何缓存存储，包括浏览器和代理服务器。
- `private`：指示资源只能被用户的浏览器缓存，不能被共享缓存（如代理服务器）存储。
- `max-age=<seconds>`：指定资源可以被缓存的最大时间（以秒为单位）。在此时间内，缓存资源被视为有效，不需要重新验证。
- `no-cache`：强制客户端在使用缓存资源前必须向服务器验证其有效性。
- `no-store`：禁止缓存，资源每次都需要从服务器获取。
- `must-revalidate`：一旦缓存过期，必须向服务器验证有效性。

```http
Cache-Control: public, max-age=3600
```

上面的代码，表示资源可以被任何缓存存储，并且缓存有效期为1小时（3600秒）。

#### （4）Cache-Control 与 Expires 的关系

`Cache-Control` 和 `Expires` 可以同时使用，但 `Cache-Control` 的优先级更高。如果同时存在，浏览器会忽略 `Expires` 而使用 `Cache-Control` 的设置。

```http
Cache-Control: public, max-age=3600
Expires: Wed, 21 Oct 2023 07:28:00 GMT
```

上面的代码，表示浏览器将根据 `Cache-Control` 头中的 `max-age` 计算缓存过期时间，而忽略 `Expires` 头。

### 2.2 协商缓存

协商缓存机制通过在 HTTP 请求和响应中使用特定的头部字段来实现。客户端在每次请求资源时，会携带前一次响应中缓存的标识信息（`ETag` 或 `Last-Modified`），服务器根据这些标识信息决定资源是否需要更新。如果资源没有变动，服务器返回 `304 Not Modified` 响应，指示客户端继续使用缓存的资源。

#### （1）Last-Modified 和 If-Modified-Since

`Last-Modified` 是 HTTP 1.0 引入的缓存控制头，它表示资源的最后修改时间。客户端在后续请求中使用 `If-Modified-Since` 头携带缓存的最后修改时间，服务器通过比较修改时间决定资源是否更新。

服务器在响应中包含 `Last-Modified` 头，用于标识资源的最后修改时间。

```http
HTTP/1.1 200 OK
Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
Content-Type: text/html
```

客户端在后续请求中，使用 `If-Modified-Since` 头，携带上次服务器返回的 `Last-Modified` 时间，要求服务器验证资源是否更新。

```http
GET /index.html HTTP/1.1
Host: www.example.com
If-Modified-Since: Wed, 21 Oct 2023 07:28:00 GMT
```

如果资源未更新，则服务器返回 `304 Not Modified` 响应，指示客户端使用缓存的资源。

```http
HTTP/1.1 304 Not Modified
Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
```

如果资源已更新，则服务器返回 `200 OK` 响应，并包含新的资源内容和 `Last-Modified` 时间。

```http
HTTP/1.1 200 OK
Last-Modified: Thu, 22 Oct 2023 08:30:00 GMT
Content-Type: text/html
```

注意，由于 `Last-Modified` 只关注文件的最后修改时间，和文件内容无关。所以，如果文件内容在修改后又重新恢复，也会导致文件的最后修改时间发生变化。此时，客户端并不会使用缓存。

此外，`Last-Modified` ​只能监听到秒级别的文件修改，如果文件在1秒内进行了修改，那么响应头返回的 `Last-Modified​` 的时间是不变的。此时客户端会认为资源没有更新，从而错误地使用缓存的资源文件。

基于上述原因，在 HTTP 1.1 中，使用 `Etag` 的方法进行协商缓存。

#### （2）ETag 和 If-None-Match

`ETag` 是 HTTP 1.1 引入的缓存控制头，它是一种标识资源特定版本的标识符。在每次资源更新时，服务器生成一个新的 `ETag`。客户端在后续请求中使用 `If-None-Match` 头携带缓存的 `ETag`，服务器通过比较 `ETag` 决定资源是否更新。

服务器在响应中包含 `ETag` 头，用于标识资源的版本。

```http
HTTP/1.1 200 OK
ETag: "5d8c72a5edda2a1"
Content-Type: text/html
```

客户端在后续请求中使用 `If-None-Match` 头携带缓存的 ETag，要求服务器验证资源是否更新。

```http
GET /index.html HTTP/1.1
Host: www.example.com
If-None-Match: "5d8c72a5edda2a1"
```

如果资源未更新，则服务器返回 `304 Not Modified` 响应，指示客户端使用缓存的资源。

```http
HTTP/1.1 304 Not Modified
ETag: "5d8c72a5edda2a1"
```

如果资源已更新，则服务器返回 `200 OK` 响应，并包含新的资源内容和 ETag。

```http
HTTP/1.1 200 OK
ETag: "6a7b8c9d10ef11"
Content-Type: text/html
```

#### （3）协商缓存的工作流程

1. **初次请求**：客户端请求资源，服务器返回资源内容和缓存验证信息（`ETag` 或 `Last-Modified`）。
2. **存储缓存**：客户端存储资源和验证信息（`ETag` 或 `Last-Modified`）。
3. **后续请求**：客户端再次请求资源时，携带缓存验证信息（`If-None-Match` 或 `If-Modified-Since`）。
4. **服务器验证**：服务器根据验证信息决定资源是否更新：
   - 如果资源未更新，返回 `304 Not Modified` 响应，客户端使用缓存。
   - 如果资源已更新，返回新的资源内容和验证信息。

对于频繁变动的动态内容，如 API 响应、动态生成的 HTML 页面，适合使用协商缓存。通过 `ETag` 或 `Last-Modified`，可以避免重复下载未变动的内容，提升性能。

对于用户特定的数据，如用户配置文件、购物车数据，使用协商缓存可以确保用户始终获取最新数据，同时减少服务器负载。

## 三、磁盘缓存和内存缓存

在 HTTP 缓存机制中，浏览器通常会使用两种主要的缓存存储方式：磁盘缓存（Disk Cache）和内存缓存（Memory Cache）。这两种缓存方式各有优缺点，适用于不同的场景。

### 3.1 磁盘缓存（Disk Cache）

磁盘缓存是将缓存的资源存储在客户端设备的硬盘或固态硬盘上。由于磁盘存储空间通常较大，可以容纳较多的缓存数据。

磁盘缓存的特点：

- **持久性**：磁盘缓存是一种持久性存储，即使关闭浏览器或重启设备，缓存的数据仍然保留。
- **容量大**：磁盘缓存可以存储大量的数据，适合存储大文件和不常变动的资源。
- **访问速度相对较慢**：相比内存缓存，访问磁盘缓存的数据速度较慢，因为涉及磁盘 I/O 操作。

磁盘缓存的适用场景：

- **静态资源**：磁盘缓存适合存储不经常变化的静态资源，如图片、CSS 文件、JavaScript 文件等。
- **大文件**：由于磁盘缓存的容量较大，适合存储体积较大的文件，如视频、音频等。

### 3.2 内存缓存（Memory Cache）

内存缓存是将缓存的资源存储在客户端设备的内存（RAM）中。由于内存的读写速度快，可以快速访问缓存的数据。

内存缓存的特点：

- **访问速度快**：内存缓存的访问速度非常快，因为数据存储在内存中，读写速度远快于磁盘。
- **容量小**：内存缓存的容量较小，通常用于存储较小和频繁访问的数据。
- **非持久性**：内存缓存是一种非持久性存储，当浏览器关闭或设备重启时，缓存的数据将被清除。

内存缓存的适用场景：

- **频繁访问的数据**：内存缓存适合存储频繁访问的资源，如页面脚本、样式表等。
- **小文件和数据**：由于内存容量有限，适合存储体积较小且经常需要快速访问的文件和数据。

### 3.3 磁盘缓存和内存缓存的协调使用

浏览器通常会同时使用磁盘缓存和内存缓存，以便在性能和存储效率之间取得平衡。

首先，当用户首次访问页面时，资源会被缓存到磁盘缓存中。对于频繁访问的资源，会同时缓存到内存中以提高访问速度。浏览器可能会预加载一些资源，并将它们存储在内存缓存中，以便在用户需要时快速提供。

其次，当资源更新时，浏览器会同时更新磁盘缓存和内存缓存中的数据，以确保用户获取到最新版本的资源。

此外，浏览器会定期清理内存缓存和磁盘缓存中不常用的资源。

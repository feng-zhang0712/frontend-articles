# 垃圾回收机制

浏览器中的垃圾回收机制（Garbage Collection，简称 GC）是 JavaScript 引擎管理内存的关键部分。它负责自动回收不再需要的内存，以防止内存泄漏和保持应用程序的性能。

## 一、概念

在高层次上，垃圾回收的任务是识别和回收不再被引用的内存。

## 二、标记清楚算法和引用计数算法

JavaScript 中的垃圾回收通常基于以下两个主要算法：

1. **标记-清除算法（Mark-and-Sweep）**
2. **引用计数算法（Reference Counting）**

### 1. 标记-清除算法（Mark-and-Sweep）

标记-清除算法是现代JavaScript引擎中最常用的垃圾回收算法。它的工作流程如下：

- **标记阶段**：从根对象（全局对象或局部作用域）开始，标记所有可到达的对象。可到达的对象是指那些可以通过引用链访问的对象。
- **清除阶段**：遍历所有对象，回收那些没有被标记的对象（即那些不可到达的对象）的内存。

```javascript
let obj1 = { a: 1 };
let obj2 = { b: 2 };

obj1.next = obj2; // obj1 引用 obj2
obj2.prev = obj1; // obj2 引用 obj1

obj1 = null; // 断开 obj1 的引用

// 垃圾回收器执行时，会发现 obj1 不可到达，而 obj2 仍然可到达（通过全局对象的引用）
```

### 2. 引用计数算法（Reference Counting）

引用计数是一种较早的垃圾回收算法，它维护每个对象的引用计数，当引用计数变为零时，该对象的内存就可以被回收。

**缺点**：引用计数算法无法处理循环引用问题，例如两个对象互相引用但不再被其他对象引用时，它们的计数不会变为零，导致内存泄漏。

```javascript
function createCycle() {
  let obj1 = {};
  let obj2 = {};

  obj1.next = obj2; // obj1 引用 obj2
  obj2.prev = obj1; // obj2 引用 obj1

  return 'Cycle created'; // 由于 obj1 和 obj2 互相引用，它们的引用计数不会变为零
}

createCycle(); // 虽然 createCycle 函数退出，但 obj1 和 obj2 无法被回收
```

现代浏览器通常不会单独使用引用计数算法，而是结合标记-清除算法来处理循环引用问题。

### 垃圾回收的触发条件

垃圾回收器并不会在每一时刻都运行，它会在以下几种情况下被触发：

1. **内存分配达到一定阈值**：当分配的内存达到预定阈值时，垃圾回收器会启动。
2. **内存申请失败**：当尝试分配新内存但失败时，垃圾回收器可能会被触发以释放内存。
3. **闲时触发**：一些垃圾回收器会在浏览器空闲时主动运行，以保持内存的健康状态。

### 垃圾回收的优化策略

现代浏览器的JavaScript引擎实现了多个优化策略来提高垃圾回收的效率：

1. **增量收集（Incremental Garbage Collection）**：
   - 将垃圾回收过程分成多个小步骤，避免长时间的卡顿。

2. **分代收集（Generational Garbage Collection）**：
   - 将内存分为不同的代（如新生代和老生代），新生成的对象放在新生代，存活较长时间的对象移动到老生代。新生代中的对象通常很快会被回收。

3. **并行收集（Parallel Garbage Collection）**：
   - 使用多线程并行执行垃圾回收任务，提高性能。

## 三、内存泄漏产生的原因

## 四、如何防止内存泄漏
